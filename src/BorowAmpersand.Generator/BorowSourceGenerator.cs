using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace BorowAmpersand.Generator;

[Generator]
public sealed class BorowSourceGenerator : IIncrementalGenerator
{
    private static readonly DiagnosticDescriptor Bor001Descriptor = new(
        id: "BOR001",
        title: "Invalid borow operand",
        messageFormat: "cannot take &borow of temporary object",
        category: "BorowAmpersand",
        defaultSeverity: DiagnosticSeverity.Error,
        isEnabledByDefault: true,
        description: "Temporary objects have no life purpose.");

    private static readonly DiagnosticDescriptor Bor404Descriptor = new(
        id: "BOR404",
        title: "Variable has no personality",
        messageFormat: "variable '{0}' has no personality",
        category: "BorowAmpersand",
        defaultSeverity: DiagnosticSeverity.Error,
        isEnabledByDefault: true,
        description: "Variable is declared but never used.");

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var borFiles = context.AdditionalTextsProvider
            .Where(static file => file.Path.EndsWith(".bor.cs", StringComparison.OrdinalIgnoreCase))
            .Select(static (file, _) => new BorFile(file.Path, file.GetText()?.ToString() ?? string.Empty));

        var input = context.CompilationProvider.Combine(borFiles.Collect());
        context.RegisterSourceOutput(
            input,
            static (spc, pair) =>
            {
                var compilation = pair.Left;
                foreach (var file in pair.Right)
                {
                    ProcessFile(spc, compilation, file);
                }
            });
    }

    private static void ProcessFile(SourceProductionContext spc, Compilation compilation, BorFile file)
    {
        var sourceText = SourceText.From(file.Content, Encoding.UTF8);
        var normalized = NormalizeBorowOperators(file.Content);
        var parseOptions = GetParseOptions(compilation);
        var syntaxTree = CSharpSyntaxTree.ParseText(normalized, parseOptions, file.Path, Encoding.UTF8);
        var effectiveCompilation = compilation.AddSyntaxTrees(syntaxTree);
        var semanticModel = effectiveCompilation.GetSemanticModel(syntaxTree, ignoreAccessibility: true);
        var root = syntaxTree.GetRoot();

        var diagnostics = ValidateBorowOperands(root, semanticModel, file.Path, sourceText)
            .Concat(ValidateVariablePersonality(root, semanticModel, file.Path, sourceText))
            .ToList();

        foreach (var diagnostic in diagnostics)
        {
            spc.ReportDiagnostic(diagnostic);
        }

        if (diagnostics.Any(static d => d.Severity == DiagnosticSeverity.Error))
        {
            return;
        }

        var rewritten = new BorowRewriter(semanticModel, file.Path).Visit(root) ?? root;
        var hintName = BuildHintName(file.Path);
        var generated = "// <auto-generated />\n" + rewritten.ToFullString() + "\n";
        spc.AddSource(hintName, SourceText.From(generated, Encoding.UTF8));
    }

    private static IEnumerable<Diagnostic> ValidateBorowOperands(
        SyntaxNode root,
        SemanticModel semanticModel,
        string filePath,
        SourceText sourceText)
    {
        foreach (var invocation in root.DescendantNodes().OfType<InvocationExpressionSyntax>())
        {
            if (!IsBorowMarkerInvocation(invocation))
            {
                continue;
            }

            if (!TryParseBorowArguments(
                    invocation.ArgumentList.Arguments,
                    out var operand,
                    out _,
                    out _))
            {
                yield return CreateDiagnostic(
                    Bor001Descriptor,
                    filePath,
                    sourceText,
                    invocation.Span);
                continue;
            }

            if (IsValidBorowOperand(operand, semanticModel))
            {
                continue;
            }

            yield return CreateDiagnostic(
                Bor001Descriptor,
                filePath,
                sourceText,
                invocation.Span);
        }
    }

    private static IEnumerable<Diagnostic> ValidateVariablePersonality(
        SyntaxNode root,
        SemanticModel semanticModel,
        string filePath,
        SourceText sourceText)
    {
        var identifiers = root.DescendantNodes().OfType<IdentifierNameSyntax>().ToArray();

        foreach (var declaration in root.DescendantNodes().OfType<VariableDeclaratorSyntax>())
        {
            if (IsUsingDeclaration(declaration))
            {
                continue;
            }

            var symbol = semanticModel.GetDeclaredSymbol(declaration) as ILocalSymbol;
            if (symbol is null)
            {
                continue;
            }

            if (symbol.Name == "_")
            {
                continue;
            }

            if (HasReferences(symbol, identifiers, semanticModel))
            {
                continue;
            }

            yield return CreateDiagnostic(
                Bor404Descriptor,
                filePath,
                sourceText,
                declaration.Identifier.Span,
                symbol.Name);
        }
    }

    private static bool IsUsingDeclaration(VariableDeclaratorSyntax declaration)
    {
        return declaration.Parent?.Parent is LocalDeclarationStatementSyntax local
            && !local.UsingKeyword.IsKind(SyntaxKind.None);
    }

    private static bool HasReferences(ILocalSymbol symbol, IReadOnlyCollection<IdentifierNameSyntax> identifiers, SemanticModel semanticModel)
    {
        foreach (var identifier in identifiers)
        {
            var resolved = semanticModel.GetSymbolInfo(identifier).Symbol;
            if (SymbolEqualityComparer.Default.Equals(resolved, symbol))
            {
                return true;
            }
        }

        return false;
    }

    private static bool IsValidBorowOperand(ExpressionSyntax operand, SemanticModel semanticModel)
    {
        if (operand is ElementAccessExpressionSyntax)
        {
            return true;
        }

        var symbolInfo = semanticModel.GetSymbolInfo(operand);
        var symbol = symbolInfo.Symbol ?? symbolInfo.CandidateSymbols.FirstOrDefault();
        if (symbol is null)
        {
            return false;
        }

        return symbol switch
        {
            ILocalSymbol local => !local.IsConst,
            IParameterSymbol parameter => parameter.RefKind != RefKind.In,
            IFieldSymbol field => !field.IsConst && !field.IsReadOnly,
            IPropertySymbol property => property.ReturnsByRef,
            _ => false
        };
    }

    private static bool IsBorowMarkerInvocation(InvocationExpressionSyntax invocation)
    {
        return invocation.Expression is IdentifierNameSyntax { Identifier.ValueText: "_bor" };
    }

    private static bool IsBorowContextMarkerInvocation(InvocationExpressionSyntax invocation)
    {
        return invocation.Expression is IdentifierNameSyntax { Identifier.ValueText: "_borctx" };
    }

    private static bool TryParseBorowArguments(
        SeparatedSyntaxList<ArgumentSyntax> arguments,
        out ExpressionSyntax operand,
        out ExpressionSyntax? context,
        out ExpressionSyntax? conceptId)
    {
        operand = null!;
        context = null;
        conceptId = null;

        if (arguments.Count == 0 || arguments.Count > 3)
        {
            return false;
        }

        var operandAssigned = false;
        var contextAssigned = false;
        var conceptAssigned = false;

        foreach (var argument in arguments)
        {
            if (argument.NameColon is { } named)
            {
                var name = named.Name.Identifier.ValueText;
                switch (name)
                {
                    case "value":
                    case "operand":
                        if (operandAssigned)
                        {
                            return false;
                        }

                        operand = argument.Expression;
                        operandAssigned = true;
                        break;
                    case "context":
                        if (contextAssigned)
                        {
                            return false;
                        }

                        context = argument.Expression;
                        contextAssigned = true;
                        break;
                    case "conceptId":
                        if (conceptAssigned)
                        {
                            return false;
                        }

                        conceptId = argument.Expression;
                        conceptAssigned = true;
                        break;
                    default:
                        return false;
                }

                continue;
            }

            if (!operandAssigned)
            {
                operand = argument.Expression;
                operandAssigned = true;
                continue;
            }

            if (!contextAssigned)
            {
                context = argument.Expression;
                contextAssigned = true;
                continue;
            }

            if (!conceptAssigned)
            {
                conceptId = argument.Expression;
                conceptAssigned = true;
                continue;
            }

            return false;
        }

        return operandAssigned;
    }

    private static CSharpParseOptions GetParseOptions(Compilation compilation)
    {
        var firstTree = compilation.SyntaxTrees.OfType<CSharpSyntaxTree>().FirstOrDefault();
        return (firstTree?.Options as CSharpParseOptions) ?? CSharpParseOptions.Default;
    }

    private static string NormalizeBorowOperators(string source)
    {
        var builder = new StringBuilder(source.Length);
        var state = ScanState.Code;

        for (var i = 0; i < source.Length;)
        {
            var c = source[i];
            var next = i + 1 < source.Length ? source[i + 1] : '\0';

            switch (state)
            {
                case ScanState.Code:
                    if (c == '/' && next == '/')
                    {
                        builder.Append(c);
                        builder.Append(next);
                        i += 2;
                        state = ScanState.LineComment;
                        continue;
                    }

                    if (c == '/' && next == '*')
                    {
                        builder.Append(c);
                        builder.Append(next);
                        i += 2;
                        state = ScanState.BlockComment;
                        continue;
                    }

                    if (c == '@' && next == '"')
                    {
                        builder.Append(c);
                        builder.Append(next);
                        i += 2;
                        state = ScanState.VerbatimString;
                        continue;
                    }

                    if (c == '"')
                    {
                        builder.Append(c);
                        i++;
                        state = ScanState.String;
                        continue;
                    }

                    if (c == '\'')
                    {
                        builder.Append(c);
                        i++;
                        state = ScanState.Char;
                        continue;
                    }

                    if (c == 'b' && TryRewriteBorowContext(source, i, out var contextConsumed, out var contextRewritten))
                    {
                        builder.Append(contextRewritten);
                        i += contextConsumed;
                        continue;
                    }

                    if (c == '&' && TryRewriteBorow(source, i, out var consumed, out var rewritten))
                    {
                        builder.Append(rewritten);
                        i += consumed;
                        continue;
                    }

                    builder.Append(c);
                    i++;
                    continue;
                case ScanState.LineComment:
                    builder.Append(c);
                    i++;
                    if (c == '\n')
                    {
                        state = ScanState.Code;
                    }

                    continue;
                case ScanState.BlockComment:
                    builder.Append(c);
                    i++;
                    if (c == '*' && i < source.Length && source[i] == '/')
                    {
                        builder.Append('/');
                        i++;
                        state = ScanState.Code;
                    }

                    continue;
                case ScanState.String:
                    builder.Append(c);
                    i++;
                    if (c == '\\' && i < source.Length)
                    {
                        builder.Append(source[i]);
                        i++;
                    }
                    else if (c == '"')
                    {
                        state = ScanState.Code;
                    }

                    continue;
                case ScanState.VerbatimString:
                    builder.Append(c);
                    i++;
                    if (c == '"' && i < source.Length && source[i] == '"')
                    {
                        builder.Append(source[i]);
                        i++;
                    }
                    else if (c == '"')
                    {
                        state = ScanState.Code;
                    }

                    continue;
                case ScanState.Char:
                    builder.Append(c);
                    i++;
                    if (c == '\\' && i < source.Length)
                    {
                        builder.Append(source[i]);
                        i++;
                    }
                    else if (c == '\'')
                    {
                        state = ScanState.Code;
                    }

                    continue;
                default:
                    throw new InvalidOperationException("Unexpected scanner state.");
            }
        }

        return builder.ToString();
    }

    private static bool TryRewriteBorow(string source, int start, out int consumed, out string rewritten)
    {
        consumed = 0;
        rewritten = string.Empty;

        var index = start + 1;
        while (index < source.Length && char.IsWhiteSpace(source[index]))
        {
            index++;
        }

        const string keyword = "borow";
        if (!MatchesWord(source, index, keyword))
        {
            return false;
        }

        index += keyword.Length;
        while (index < source.Length && char.IsWhiteSpace(source[index]))
        {
            index++;
        }

        if (index >= source.Length)
        {
            return false;
        }

        var operand = string.Empty;
        int operandEnd;

        if (source[index] == '(')
        {
            if (!TryReadParenthesizedArgumentList(source, index, out operand, out operandEnd))
            {
                return false;
            }
        }
        else if (!TryReadOperand(source, index, out operandEnd))
        {
            return false;
        }
        else
        {
            operand = source.Substring(index, operandEnd - index).Trim();
        }

        if (string.IsNullOrWhiteSpace(operand))
        {
            return false;
        }

        consumed = operandEnd - start;
        var replacementCore = "_bor(" + operand + ")";
        var paddingLength = consumed - replacementCore.Length;
        rewritten = paddingLength <= 0
            ? replacementCore
            : replacementCore + new string(' ', paddingLength);
        return true;
    }

    private static bool TryRewriteBorowContext(string source, int start, out int consumed, out string rewritten)
    {
        consumed = 0;
        rewritten = string.Empty;

        const string keyword = "borowcontext";
        if (!MatchesWord(source, start, keyword))
        {
            return false;
        }

        var index = start + keyword.Length;
        while (index < source.Length && char.IsWhiteSpace(source[index]))
        {
            index++;
        }

        if (index >= source.Length || source[index] != '(')
        {
            return false;
        }

        if (!TryReadParenthesizedArgumentList(source, index, out var arguments, out var endExclusive))
        {
            return false;
        }

        consumed = endExclusive - start;
        var replacementCore = "_borctx(" + arguments + ")";
        var paddingLength = consumed - replacementCore.Length;
        rewritten = paddingLength <= 0
            ? replacementCore
            : replacementCore + new string(' ', paddingLength);
        return true;
    }

    private static bool TryReadParenthesizedArgumentList(
        string source,
        int openParenIndex,
        out string argumentsText,
        out int endExclusive)
    {
        argumentsText = string.Empty;
        endExclusive = openParenIndex;

        if (openParenIndex >= source.Length || source[openParenIndex] != '(')
        {
            return false;
        }

        var depth = 0;
        for (var i = openParenIndex; i < source.Length; i++)
        {
            var c = source[i];
            if (c == '(')
            {
                depth++;
            }
            else if (c == ')')
            {
                depth--;
                if (depth == 0)
                {
                    argumentsText = source.Substring(openParenIndex + 1, i - openParenIndex - 1).Trim();
                    endExclusive = i + 1;
                    return true;
                }
            }
        }

        return false;
    }

    private static bool MatchesWord(string source, int index, string word)
    {
        if (index > 0 && IsIdentifierPart(source[index - 1]))
        {
            return false;
        }

        if (index + word.Length > source.Length)
        {
            return false;
        }

        for (var i = 0; i < word.Length; i++)
        {
            if (source[index + i] != word[i])
            {
                return false;
            }
        }

        var wordEnd = index + word.Length;
        if (wordEnd < source.Length && IsIdentifierPart(source[wordEnd]))
        {
            return false;
        }

        return true;
    }

    private static bool TryReadOperand(string source, int start, out int operandEnd)
    {
        var parenDepth = 0;
        var bracketDepth = 0;
        var braceDepth = 0;
        var index = start;

        while (index < source.Length)
        {
            var c = source[index];
            switch (c)
            {
                case '(':
                    parenDepth++;
                    break;
                case ')':
                    if (parenDepth == 0 && bracketDepth == 0 && braceDepth == 0)
                    {
                        goto done;
                    }

                    parenDepth = Math.Max(parenDepth - 1, 0);
                    break;
                case '[':
                    bracketDepth++;
                    break;
                case ']':
                    if (parenDepth == 0 && bracketDepth == 0 && braceDepth == 0)
                    {
                        goto done;
                    }

                    bracketDepth = Math.Max(bracketDepth - 1, 0);
                    break;
                case '{':
                    braceDepth++;
                    break;
                case '}':
                    if (parenDepth == 0 && bracketDepth == 0 && braceDepth == 0)
                    {
                        goto done;
                    }

                    braceDepth = Math.Max(braceDepth - 1, 0);
                    break;
                case ';':
                case ',':
                case '\r':
                case '\n':
                    if (parenDepth == 0 && bracketDepth == 0 && braceDepth == 0)
                    {
                        goto done;
                    }

                    break;
            }

            index++;
        }

done:
        while (index > start && char.IsWhiteSpace(source[index - 1]))
        {
            index--;
        }

        operandEnd = index;
        return operandEnd > start;
    }

    private static bool IsIdentifierPart(char c)
    {
        return char.IsLetterOrDigit(c) || c == '_';
    }

    private static string BuildHintName(string path)
    {
        var fileName = path.Split('\\', '/').Last();
        return fileName.Replace('.', '_') + ".g.cs";
    }

    private static string BuildConceptId(ISymbol? symbol, string fallbackPath, int fallbackPosition, string fallbackName)
    {
        if (symbol is null)
        {
            return $"{NormalizePath(fallbackPath)}:{fallbackPosition}:{fallbackName}";
        }

        var location = symbol.Locations.FirstOrDefault(static loc => loc.IsInSource);
        var path = NormalizePath(location?.SourceTree?.FilePath ?? fallbackPath);
        var position = location?.SourceSpan.Start ?? fallbackPosition;
        var container = symbol.ContainingSymbol?.ToDisplayString(SymbolDisplayFormat.CSharpErrorMessageFormat) ?? "global";
        return $"{path}:{position}:{symbol.Name}:{container}";
    }

    private static string NormalizePath(string path)
    {
        return path.Replace('\\', '/');
    }

    private static Diagnostic CreateDiagnostic(
        DiagnosticDescriptor descriptor,
        string path,
        SourceText sourceText,
        TextSpan span,
        params object[] args)
    {
        var safeSpan = ClampToSource(span, sourceText.Length);
        var location = Location.Create(path, safeSpan, sourceText.Lines.GetLinePositionSpan(safeSpan));
        return Diagnostic.Create(descriptor, location, args);
    }

    private static TextSpan ClampToSource(TextSpan span, int sourceLength)
    {
        var start = Math.Max(0, Math.Min(span.Start, sourceLength));
        var end = Math.Max(start, Math.Min(span.End, sourceLength));
        return TextSpan.FromBounds(start, end);
    }

    private sealed class BorowRewriter : CSharpSyntaxRewriter
    {
        private readonly SemanticModel _semanticModel;
        private readonly string _filePath;

        public BorowRewriter(SemanticModel semanticModel, string filePath)
        {
            _semanticModel = semanticModel;
            _filePath = filePath;
        }

        public override SyntaxNode? VisitPrefixUnaryExpression(PrefixUnaryExpressionSyntax node)
        {
            var rewritten = (PrefixUnaryExpressionSyntax)(base.VisitPrefixUnaryExpression(node) ?? node);
            if (!rewritten.IsKind(SyntaxKind.PointerIndirectionExpression))
            {
                return rewritten;
            }

            var valueAccess = SyntaxFactory.MemberAccessExpression(
                SyntaxKind.SimpleMemberAccessExpression,
                ParenthesizeIfNeeded(rewritten.Operand),
                SyntaxFactory.IdentifierName("Value"));

            return valueAccess.WithTriviaFrom(rewritten);
        }

        public override SyntaxNode? VisitGenericName(GenericNameSyntax node)
        {
            var rewritten = (GenericNameSyntax)(base.VisitGenericName(node) ?? node);
            if (!IsBorowTypeAlias(rewritten))
            {
                return rewritten;
            }

            var typeArguments = string.Join(", ", rewritten.TypeArgumentList.Arguments.Select(static arg => arg.ToString()));
            var replacement = SyntaxFactory.ParseTypeName(
                $"global::BorowAmpersand.Runtime.BorowRef<{typeArguments}>");
            return replacement.WithTriviaFrom(rewritten);
        }

        public override SyntaxNode? VisitInvocationExpression(InvocationExpressionSyntax node)
        {
            if (IsBorowContextMarkerInvocation(node))
            {
                return RewriteBorowContextInvocation(node);
            }

            if (IsBorowMarkerInvocation(node))
            {
                return RewriteBorowInvocation(node);
            }

            var rewritten = (InvocationExpressionSyntax)(base.VisitInvocationExpression(node) ?? node);
            if (!IsConsoleWriteLineInvocation(rewritten) || rewritten.ArgumentList.Arguments.Count != 1)
            {
                return rewritten;
            }

            var argument = rewritten.ArgumentList.Arguments[0];
            if (!IsBorowRuntimeInvocation(argument.Expression))
            {
                return rewritten;
            }

            var toStringCall = SyntaxFactory.InvocationExpression(
                SyntaxFactory.MemberAccessExpression(
                    SyntaxKind.SimpleMemberAccessExpression,
                    ParenthesizeIfNeeded(argument.Expression),
                    SyntaxFactory.IdentifierName("ToString")));

            var updatedArgument = argument.WithExpression(toStringCall);
            var updatedArguments = SyntaxFactory.SingletonSeparatedList(updatedArgument);
            return rewritten.WithArgumentList(rewritten.ArgumentList.WithArguments(updatedArguments));
        }

        private ObjectCreationExpressionSyntax RewriteBorowContextInvocation(InvocationExpressionSyntax node)
        {
            var argumentList = (ArgumentListSyntax)(Visit(node.ArgumentList) ?? node.ArgumentList);
            var template = (ObjectCreationExpressionSyntax)SyntaxFactory.ParseExpression(
                "new global::BorowAmpersand.Runtime.BorowContext()");

            return template
                .WithArgumentList(argumentList)
                .WithTriviaFrom(node);
        }

        private InvocationExpressionSyntax RewriteBorowInvocation(InvocationExpressionSyntax node)
        {
            if (!TryParseBorowArguments(
                    node.ArgumentList.Arguments,
                    out var operand,
                    out var contextArg,
                    out var conceptIdArg))
            {
                return node;
            }

            var rewrittenOperand = (ExpressionSyntax)(Visit(operand) ?? operand);
            var symbolInfo = _semanticModel.GetSymbolInfo(operand);
            var symbol = symbolInfo.Symbol ?? symbolInfo.CandidateSymbols.FirstOrDefault();
            var conceptId = BuildConceptId(symbol, _filePath, operand.SpanStart, operand.ToString());

            var target = SyntaxFactory.ParseExpression("global::BorowAmpersand.Runtime.Borow.Ampersand");
            var arguments = new List<ArgumentSyntax>
            {
                SyntaxFactory.Argument(rewrittenOperand)
                    .WithRefKindKeyword(
                        SyntaxFactory.Token(
                            SyntaxFactory.TriviaList(),
                            SyntaxKind.RefKeyword,
                            SyntaxFactory.TriviaList(SyntaxFactory.Space)))
            };

            if (contextArg is not null)
            {
                arguments.Add(
                    SyntaxFactory.Argument((ExpressionSyntax)(Visit(contextArg) ?? contextArg))
                        .WithNameColon(SyntaxFactory.NameColon(SyntaxFactory.IdentifierName("context"))));
            }

            if (conceptIdArg is not null)
            {
                arguments.Add(
                    SyntaxFactory.Argument((ExpressionSyntax)(Visit(conceptIdArg) ?? conceptIdArg))
                        .WithNameColon(SyntaxFactory.NameColon(SyntaxFactory.IdentifierName("conceptId"))));
            }
            else
            {
                arguments.Add(
                    SyntaxFactory.Argument(
                            SyntaxFactory.LiteralExpression(
                                SyntaxKind.StringLiteralExpression,
                                SyntaxFactory.Literal(conceptId)))
                        .WithNameColon(SyntaxFactory.NameColon(SyntaxFactory.IdentifierName("conceptId"))));
            }

            return SyntaxFactory.InvocationExpression(target, SyntaxFactory.ArgumentList(SyntaxFactory.SeparatedList(arguments)))
                .WithTriviaFrom(node);
        }

        private static bool IsConsoleWriteLineInvocation(InvocationExpressionSyntax invocation)
        {
            return invocation.Expression is MemberAccessExpressionSyntax
            {
                Name.Identifier.ValueText: "WriteLine",
                Expression: IdentifierNameSyntax { Identifier.ValueText: "Console" }
            };
        }

        private static bool IsBorowRuntimeInvocation(ExpressionSyntax expression)
        {
            expression = UnwrapParentheses(expression);
            if (expression is not InvocationExpressionSyntax invocation)
            {
                return false;
            }

            return invocation.Expression is MemberAccessExpressionSyntax
            {
                Name.Identifier.ValueText: "Ampersand"
            } member && member.Expression.ToString().EndsWith("Borow", StringComparison.Ordinal);
        }

        private static bool IsBorowTypeAlias(GenericNameSyntax node)
        {
            return string.Equals(node.Identifier.ValueText, "borow", StringComparison.Ordinal)
                && IsTypeContext(node);
        }

        private static bool IsTypeContext(CSharpSyntaxNode node)
        {
            return node.Parent switch
            {
                ParameterSyntax parent => parent.Type == node,
                VariableDeclarationSyntax parent => parent.Type == node,
                MethodDeclarationSyntax parent => parent.ReturnType == node,
                LocalFunctionStatementSyntax parent => parent.ReturnType == node,
                PropertyDeclarationSyntax parent => parent.Type == node,
                EventDeclarationSyntax parent => parent.Type == node,
                CastExpressionSyntax parent => parent.Type == node,
                ObjectCreationExpressionSyntax parent => parent.Type == node,
                ArrayTypeSyntax parent => parent.ElementType == node,
                NullableTypeSyntax parent => parent.ElementType == node,
                RefTypeSyntax parent => parent.Type == node,
                DefaultExpressionSyntax parent => parent.Type == node,
                TypeOfExpressionSyntax parent => parent.Type == node,
                SizeOfExpressionSyntax parent => parent.Type == node,
                TupleElementSyntax parent => parent.Type == node,
                TypeArgumentListSyntax => true,
                QualifiedNameSyntax parent when parent.Right == node => IsTypeContext(parent),
                AliasQualifiedNameSyntax parent when parent.Name == node => IsTypeContext(parent),
                UsingDirectiveSyntax parent => parent.Name == node,
                _ => false
            };
        }

        private static ExpressionSyntax UnwrapParentheses(ExpressionSyntax expression)
        {
            while (expression is ParenthesizedExpressionSyntax parenthesized)
            {
                expression = parenthesized.Expression;
            }

            return expression;
        }

        private static ExpressionSyntax ParenthesizeIfNeeded(ExpressionSyntax expression)
        {
            expression = UnwrapParentheses(expression);
            return expression switch
            {
                IdentifierNameSyntax => expression,
                MemberAccessExpressionSyntax => expression,
                InvocationExpressionSyntax => expression,
                ElementAccessExpressionSyntax => expression,
                ThisExpressionSyntax => expression,
                BaseExpressionSyntax => expression,
                _ => SyntaxFactory.ParenthesizedExpression(expression)
            };
        }
    }

    private sealed class BorFile
    {
        public BorFile(string path, string content)
        {
            Path = path;
            Content = content;
        }

        public string Path { get; }
        public string Content { get; }
    }

    private enum ScanState
    {
        Code,
        LineComment,
        BlockComment,
        String,
        VerbatimString,
        Char
    }
}
